{"version":3,"sources":["../src/helpers.ts","../src/put.ts"],"names":[],"mappings":"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","sourcesContent":["// common util interface for blob raw commands, not meant to be used directly\n// this is why it's not exported from index/client\n\nimport { type Response } from 'undici';\n\nexport interface BlobCommandOptions {\n  /**\n   * Define your blob API token.\n   * @defaultvalue process.env.BLOB_READ_WRITE_TOKEN\n   */\n  token?: string;\n}\n\n// shared interface for put and copy\nexport interface CreateBlobCommandOptions extends BlobCommandOptions {\n  /**\n   * Whether the blob should be publicly accessible. Support for private blobs is planned.\n   */\n  access: 'public';\n  /**\n   * Adds a random suffix to the filename.\n   * @defaultvalue true\n   */\n  addRandomSuffix?: boolean;\n  /**\n   * Defines the content type of the blob. By default, this value is inferred from the pathname. Sent as the 'content-type' header when downloading a blob.\n   */\n  contentType?: string;\n  /**\n   * Number in seconds to configure the edge and browser cache. The maximum values are 5 minutes for the edge cache and unlimited for the browser cache.\n   * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob#caching\n   * @defaultvalue 365 * 24 * 60 * 60 (1 Year)\n   */\n  cacheControlMaxAge?: number;\n}\n\nexport function getTokenFromOptionsOrEnv(options?: BlobCommandOptions): string {\n  if (options?.token) {\n    return options.token;\n  }\n\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n\n  throw new BlobError(\n    'No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.',\n  );\n}\n\nexport class BlobError extends Error {\n  constructor(message: string) {\n    super(`Vercel Blob: ${message}`);\n  }\n}\n\nexport class BlobAccessError extends BlobError {\n  constructor() {\n    super('Access denied, please provide a valid token for this resource');\n  }\n}\n\nexport class BlobStoreNotFoundError extends BlobError {\n  constructor() {\n    super('This store does not exist');\n  }\n}\n\nexport class BlobStoreSuspendedError extends BlobError {\n  constructor() {\n    super('This store has been suspended');\n  }\n}\n\nexport class BlobUnknownError extends BlobError {\n  constructor() {\n    super('Unknown error, please visit https://vercel.com/help');\n  }\n}\n\nexport class BlobNotFoundError extends BlobError {\n  constructor() {\n    super('The requested blob does not exist');\n  }\n}\n\nexport class BlobServiceNotAvailable extends BlobError {\n  constructor() {\n    super('The blob service is currently not available. Please try again');\n  }\n}\n\ntype BlobApiErrorCodes =\n  | 'store_suspended'\n  | 'forbidden'\n  | 'not_found'\n  | 'unknown_error'\n  | 'bad_request'\n  | 'store_not_found'\n  | 'not_allowed'\n  | 'service_unavailable';\n\ninterface BlobApiError {\n  error?: { code?: BlobApiErrorCodes; message?: string };\n}\n\nexport async function validateBlobApiResponse(\n  response: Response,\n): Promise<void> {\n  if (!response.ok) {\n    let data: unknown;\n\n    try {\n      data = await response.json();\n    } catch {\n      throw new BlobUnknownError();\n    }\n\n    const error = (data as BlobApiError).error;\n\n    switch (error?.code) {\n      case 'store_suspended':\n        throw new BlobStoreSuspendedError();\n      case 'forbidden':\n        throw new BlobAccessError();\n      case 'not_found':\n        throw new BlobNotFoundError();\n      case 'store_not_found':\n        throw new BlobStoreNotFoundError();\n      case 'bad_request':\n        throw new BlobError(error.message ?? 'Bad request');\n      case 'service_unavailable':\n        throw new BlobServiceNotAvailable();\n      case 'unknown_error':\n      case 'not_allowed':\n      default:\n        throw new BlobUnknownError();\n    }\n  }\n}\n\n// This version is used to ensure that the client and server are compatible\n// The server (Vercel Blob API) uses this information to change its behavior like the\n// response format\nconst BLOB_API_VERSION = 5;\n\nexport function getApiVersionHeader(): { 'x-api-version'?: string } {\n  let versionOverride = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to the BLOB_API_VERSION\n    versionOverride =\n      process.env.VERCEL_BLOB_API_VERSION_OVERRIDE ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n    // noop\n  }\n\n  return {\n    'x-api-version': `${versionOverride ?? BLOB_API_VERSION}`,\n  };\n}\n\nexport function getApiUrl(pathname = ''): string {\n  let baseUrl = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to production endpoint\n    baseUrl =\n      process.env.VERCEL_BLOB_API_URL ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n    // noop\n  }\n  return `${baseUrl || 'https://blob.vercel-storage.com'}${pathname}`;\n}\n","import type { Readable } from 'node:stream';\nimport type { BodyInit } from 'undici';\nimport { fetch } from 'undici';\nimport type { ClientPutCommandOptions } from './client';\nimport type { CreateBlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  BlobError,\n  validateBlobApiResponse,\n} from './helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface -- expose option interface for each API method for better extensibility in the future\nexport interface PutCommandOptions extends CreateBlobCommandOptions {}\n\nconst putOptionHeaderMap = {\n  cacheControlMaxAge: 'x-cache-control-max-age',\n  addRandomSuffix: 'x-add-random-suffix',\n  contentType: 'x-content-type',\n};\n\nexport interface PutBlobResult {\n  url: string;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n}\n\nexport type PutBlobApiResponse = PutBlobResult;\n\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport function createPutMethod<\n  T extends PartialBy<PutCommandOptions & ClientPutCommandOptions, 'token'>,\n>({\n  allowedOptions,\n  getToken,\n  extraChecks,\n}: {\n  allowedOptions: (keyof typeof putOptionHeaderMap)[];\n  getToken?: (pathname: string, options: T) => Promise<string>;\n  extraChecks?: (options: T) => void;\n}) {\n  return async function put<TPath extends string>(\n    pathname: TPath,\n    bodyOrOptions: TPath extends `${string}/`\n      ? T\n      :\n          | string\n          | Readable\n          | Blob\n          | ArrayBuffer\n          | FormData\n          | ReadableStream\n          | File,\n    optionsInput?: T,\n  ): Promise<PutBlobResult> {\n    if (!pathname) {\n      throw new BlobError('pathname is required');\n    }\n\n    const isFolderCreation = pathname.endsWith('/');\n\n    // prevent empty bodies for files\n    if (!bodyOrOptions && !isFolderCreation) {\n      throw new BlobError('body is required');\n    }\n\n    // runtime check for non TS users that provide all three args\n    if (bodyOrOptions && optionsInput && isFolderCreation) {\n      throw new BlobError('body is not allowed for creating empty folders');\n    }\n\n    // avoid using the options as body\n    const body = isFolderCreation ? undefined : (bodyOrOptions as BodyInit);\n\n    // when no body is required options are the second argument\n    const options = isFolderCreation ? (bodyOrOptions as T) : optionsInput;\n\n    if (!options) {\n      throw new BlobError('missing options, see usage');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n    if (options.access !== 'public') {\n      throw new BlobError('access must be \"public\"');\n    }\n\n    if (extraChecks) {\n      extraChecks(options);\n    }\n\n    const token = getToken\n      ? await getToken(pathname, options)\n      : getTokenFromOptionsOrEnv(options);\n\n    const headers: Record<string, string> = {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${token}`,\n    };\n\n    if (allowedOptions.includes('contentType') && options.contentType) {\n      headers['x-content-type'] = options.contentType;\n    }\n\n    if (\n      allowedOptions.includes('addRandomSuffix') &&\n      options.addRandomSuffix !== undefined\n    ) {\n      headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n    }\n\n    if (\n      allowedOptions.includes('cacheControlMaxAge') &&\n      options.cacheControlMaxAge !== undefined\n    ) {\n      headers['x-cache-control-max-age'] =\n        options.cacheControlMaxAge.toString();\n    }\n\n    const blobApiResponse = await fetch(getApiUrl(`/${pathname}`), {\n      method: 'PUT',\n      body,\n      headers,\n      // required in order to stream some body types to Cloudflare\n      // currently only supported in Node.js, we may have to feature detect this\n      duplex: 'half',\n    });\n\n    await validateBlobApiResponse(blobApiResponse);\n\n    const blobResult = (await blobApiResponse.json()) as PutBlobApiResponse;\n\n    return blobResult;\n  };\n}\n"]}